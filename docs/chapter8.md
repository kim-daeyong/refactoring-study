# 데이터 체계화

### 필드 자체 캡슐화

* 필드에 직접 접근하던 중 그 필드로의 결합된 문제가 생길땐 그 필드용 읽기/쓰기 메서드를 작성하여 그 메서드를 통해 접근

* 방법
    - 필드 읽기 메서드와 쓰기 메서드를 작성
    - 그 필드 참조부분을 전부 읽기/쓰기 메서드로 변경
    - 필드를 private로 변경
    - 참조 코드를 빠짐없이 수정했는지 확인
    - 테스트


### 데이터 값을 객체로 전환

* 테이터 항목에 데이터나 기능을 추가해야 할 때는 데이터 항목을 객체로 만든다.
    - 전화번호는 문자열로 표현될 수 있지만 기능이 추가되다보면 형식화, 지역번호등 특수기능이 필요해질 수 있다.
    - 이는 중복코드나 잘못된 소속등의 코드 구린내가 풍기게 된다.

* 방법
    - 데이터 값을 넣을 클래스를 작성, 
    - 컴파일
    - 원본 클래스에 든 필드의 타입을 새 클래스로 변환
    - 그 필드가 원본 클래스 생성자 안에서 사용된다면 새클래스의 생성자를 이용
    - 새 클래스의 새 인스턴스를 생성하게끔 읽기 메서드 수정
    - 컴파일 및 테스트
    - 새 객체에 값을 참조로 전환을 적용해야 할 수도 있다.


### 값을 참조로 전환
* 클래스에 같은 인스턴스가 많이 있어 이것들을 하나의 객체로 바꿔야 할 땐 그 객체를 참조 객체로 전환

* 방법
    - 생성자를 팩토리 메서드로 전환
    - 컴파일과 테스트를 실시
    - 참조 객체로의 접근을 담당할 객체 정하기
        - 정적 딕셔너리나 레지스트리 객체가 담당할 수도 있음
        - 참조 객체로의 접근을 둘 이상의 객체가 담당할 수도 있다.
    - 객체를 미리 생성할지 사용하기 직전에 생성할지를 정한다.
        - 객체를 미리 생성했다가 메모리에서 가져오면 사용 전에 미리 로딩되어 있는지 확인해야 한다.
    - 참조 객체를 반환하게 팩토리 메서드를 수정
        - 객체를 미리 생성할 경우, 존재하지 않는 객체 요청에 대한 에러처리를 어떻게 할지 정해야 한다.
        - 팩터리 메서드가 원본 객체를 반환함을 한눈에 알 수 있게 팩터리 메서드에 메서드명 변경을 적용해야 할 수 있다.
    - 컴파일, 테스트


### 참조를 값으로 전환 Change Reference to Value
* 참조 객체가 작고 수정할 수 없고 관리하기 힘들 땐 그 참조 객체를 값 객체로 만들자 
    - 값 객체는 변경할 수 없어야 한다는 주요 특성이 있다.

* 방법 
    - 전환할 객체가 변경불가인지 변경 가능인지 검사 
        - 전환할 객체가 변경불가가 아니면, 변경불가가 될때까지 쓰기 메서드 제거를 실시
        - 전환할 객체가 변경불가이면 이 리팩토링은 멈춘다
    - equals 메서드와 hash 메서드를 작성하자 
    - 컴파일, 테스트  
    - 팩토리 메서드를 삭제하고 생성자를 public으로 만들어야 좋을지 생각 필요

* 값객체는 생성자를 통해 생성?, 참조객체는 어떤 값을 저장하고 반환?

### 배열을 객체로 전환 Replace Array with Object  
* 배열을 구성하는 특정 원소가 별의별 의미를 지닐 땐 그 배열을 각 원소마다 필드가 하나씩 든 객체로 전환
  - 배열은 데이터 정리에 흔히 사용되는 구조이나 비슷한 객체들의 컬렉션을 일정 순서로 담는 용도로만 사용해야 한다.
  - 객체를 사용하면 필드명과 메서드명을 사용하여 이러한 정보를 전달할 수 있다. 

* 방법 
  - 배열 안의 정보를 표현할 새 클래스를 작성하자. 그 클래스 안에 배열을 저장할 public 필드를 하나 작성하자.  
  - 배열 참조 부분을 전부 새 클래스 참조로 수정하자.
  - 컴파일, 테스트 
  - 배열의 각 원소마다 참조 코드에 사용할 읽기 메서드를 하나씩 넣자. 
    - 배열 원소의 용도를 따서 읽기 메서드 이름을 정하자. 
    - 참조 부분을 읽기 메서드 호출로 전부 수정하자. 
  - 배열 참조 부분을 전부 메서드로 교체했으면 배열을 private로 만들자 
  - 컴파일
  - 클래스 안에 배열의 각 원소에 대응되는 하나의 필드를 생성한 후, 그 필드를 사용하게끔 읽기/쓰기 메서드를 수정하자 
  - 각 원소에 대한 수정을 마칠 때마다 컴파일, 테스트 
  - 모든 원소를 필드로 교체했으면 배열을 삭제

```java
  String[] row = new String[3];
  row[0] = "team";
  row[1] = "15;"

  // after
  Performance row = new Performance();
  row.setName("team");
  row.setWins("15");
```


### 관측 데이터 복제 Duplicate Observed Data  

* 도메인 데이터는 GUI 컨트롤 안에서만 사용 가능한데, 도메인 메서드가 그 데이터에 접근해야 할 땐 그 데이터를 도메인 객체로 복사하고, 양측의 데이터를 동기화하는 관측 인터페이스 observer를 작성하자
  - 계층구조가 체계적인 시스템은 비즈니스 로직 처리 코드와 사용자 인터페이스 처리 코드가 분리되어 있다. 
    - 비슷한 비즈니스 로직을 여러 인터페이스가 처리해야 하는 경우
    - 비즈니스 로직까지 처리하려면 사용자 인터페이스가 너무 복잡
    - GUI와 분리된 도메인 객체가 더욱 유지보수하기 쉬움
    - 두 부분을 서로 다른 개발자가 다루게 할 수 있음

* 방법
  - 표현 클래스를 도메인 클래스의 관측 인터페이스로 만들자  
    - 도메인 클래스가 없으면 하나 작성
    - 표현 클래스에 도메인 클래스로의 연결 코드가 없으면 표현 클래스의 필드에 도메인 클래스를 대입
  - GUI 클래스 안의 도메인 데이터를 대상으로 필드 자체 캡슐화를 실시
  - 컴파일, 테스트  
  - 이벤트 핸들러 메서드 안에 쓰기 메서드 호출 코드를 추가하자. 이 쓰기 메서드는 직접 접근 방식으로 컴포넌트를 현재 값으로 수정
  - 컴파일, 테스트 
  - 도메인 클래스 안에 데이터와 읽기/쓰기 메서드를 정의
  - 쓰기 메서드가 도메인 필드에 쓰도록 참조를 수정
  - 관측 인터페이스의 update 메서드를 도메인 필드에서 GUI 컨트롤로 데이터를 복사하게 수정
  - 컴파일, 테스트 


### 클래스의 단방향 연결을 양방향으로 전환 Change Unidirectional Association to Bidirectional
- 두 클래스가 서로의 기능을 사용해야 하는데 한 방향으로만 연결되어 있을 땐 역 포인터를 추가하고 두 클래스를 모두 업데이트할 수 있게 접근 한정자를 수정하자  

* 방법
  - 역 포인터 참조용 필드를 추가
  - 연결 제어 기능을 어느 클래스에 넣을지 결정
  - 연결 제어 기능이 없는 클래스 안에 헬퍼 메서드 작성, 그 메서드에 제한된 용도가 분명한 이름 정의
  - 기존 변경 메서드가 연결 제어 클래스에 들어있으면 역 포인터 업데이트를 하게 변경 메서드를 수정
  - 기존 변경 메서드가 연결제어 클래스에 들어있으면 제어 클래스 안에 제어 메서드를 작성. 시존 변경 메서드가 그 메서드 호출하게 지정

### 클래스의 양방향 연결을 단방향으로 전환 Change Bidirectional Association to Unidirectional
- 두 클래스가 양방향으로 연결되어 있는데 한 클래스가 다른 클래스의 기능을 더이상 사용하지않을땐 불필요한 방향 제거

### 마법 숫자를 기호 상수로 전환 Replace Magic Number with Symbolic Constant
- 특수 의미를 지닌 리터럴 숫자가 있을 땐 의미를 살린 이름의 상수를 작성한 후 리터럴 숫자를 그 상수로 교체하자 

```java
  double potentialEnergy(double mass, double height) {
      return mass * 9.81 * height;
  }
  //after

  double potentialEnergy(double mass, double height) {
      return mass * GRAVITATIONAL_CONSTANT * height;
  }
  static final double GRAVITATIONAL_CONSTANT = 9.81;
```


### 필드 캡슐화 Encapsulate Field
- public 필드가 있을 땐 그 필드를 private로 만들고 필드용 읽기 메서드오 쓰기 메서드를 작성하자 
  - 객체지향의 주요 원칙 중 하나는 캡슐화(데이터 은닉)
    - 데이터는 절대로 public 타입으로 선언하면 안된다. 
    - 데이터를 public 타입으로 만들면 데이터가 있는 객체가 모르는 사이에 다른 객체가 값을 읽고 변경할 수 있다. 
  - 프로그램의 모듈성을 저하시키는 것이 문제
    - 데이터와 데이터를 사용하는 기능이 한 곳에 있어야 코드를 수정하기 쉽다.
  - 필드 캡슐화 과정의 첫 단계는 데이터를 은닉하고 읽기/쓰기 메서드를 추가하는 것  
    - 읽기 메서드와 쓰기 메서드만 있는 클래스는 객체의 장점을 전혀 활용하지 않아서 객체라는 이름이 아까운 dumb class 
    - 필드 캡슐화를 적용한 후엔 새 메서드를 사용하는 메서드를 찾아 그 메서드를 묶어서 가단한 메서드 이동을 적용해 새 객체로 옮겨도 괜찮을지 확인

```java
  public String name;

  // after

  private String name;
  public String getName() {return name;}
  public void setName(String arg) {name = arg;}
```


### 컬렉션 캡슐화 Encapsulate Collection
- 메서드가 컬렉션을 반환할 땐 그 메서드가 _읽기전용 뷰를 반환_ 하게 수정하고 추가 메서드와 삭제 메서드를 작성하자
  - 클래스에 여러 인스턴스로 구성된 컬렉션이 들어있는 경우는 흔하다.
  - 컬렉션은 다른 종류의 데이터와 다른 읽기/쓰기 방식을 사용해야 한다.
    - 컬렉션 조작이 불가능한 형식을 반환하고 불필요하게 자세한 컬렉션 구조 정보는 감춰야 한다.
    - 컬렉션 쓰기 메서드는 절대 있으면 안되므로 원소를 추가하는 메서드와 삭제하는 메서드를 대신 사용해야 한다.
    - 이러한 규칙대로 설계를 고치면 컬렉션은 적절히 캡슐화되어 컬렉션이 든 클래스의 컬렉션 참조 부분에 대한 종속성이 줄어든다.  

* 방법
  - 컬렉션 원소를 추가하는 add 메서드와 삭제하는 remove 메서드를 추가하자
  - 필드를 빈 컬렉션으로 초기화 
  - 컴파일
  - 쓰기 메서드 호출 부분을 찾아 add, remove 메서드 호출로 바꾸거나 그 위치에 직접 컬렉션에 원소를 추가하고 삭제하는 코드를 작성하자  
    - 쓰기 메서드가 사용되는 경우는 컬렉션이 비어 있을 때, 비어있지 않은 컬렉션을 교체할 때 사용
    - 메서드명 변경을 실시해서 쓰기 메서드의 이름을 변경해야 할 수도 있다.
  - set 이라는 이름을 initialize나 replace로 수정하자.
  - 컴파일, 테스트 
  - 읽기 메서드를 호출하여 컬렉션을 변경하는 부분을 add, remove 호출로 바꾸자.
  - 컬렉션을 변경하고자 읽기 메서드를 호출하는 부분을 추가/삭제 메서드 호출로 고쳤으면 컬렉션의 읽기 전용 뷰를 반환하게 읽기 메서드를 수정
  - 컴파일, 테스트 
  - 읽기 메서드 호출 부분을 찾고 컬렉션이 든 객체로 옮겨야 할 코드를 찾아서 메서드 추출, 메서드 이동을 실시해서 컬렉션이 든 객체로 옮기자



### 레코드를 데이터 클래스로 전환 Replace Record with Data Class
- 전통적인 프로그래밍 환경에서 레코드 구조를 이용한 인터페이스를 제공해야 할 땐 레코드 구조를 저장할 덤 데이터 객체 를 작성하자
  - Dumb data : 데이터가 거의 들어 있지 않은 객체로, 기능 추가 없이 데이터에 public 속성이나 읽기/쓰기 메서드로 접근할 수 있다. 
* 방법
  - 레코드를 표현할 클래스를 작성
  - 그 클래스에 각 데이터 항목에 대한 읽기 메서드와 쓰기 메서드 작성, private 필드 선언


### 분류 부호를 클래스로 전환 Replace Type Code with Class
- 기능에 영향을 미치는 숫자형 분류 부호가 든 클래스가 있을 땐 그 숫자를 새 클래스로 바꾸자
  - 숫자형 분류 부호를 클래스로 빼내면 컴파일러는 그 클래스 안에서 종류 판단을 수행할 수 있다.  

* 방법
  - 분류 부호의 종류를 판단할 새 클래스를 작성
    - 생성이 허용되는 인스턴스를 저장할 static 변수와 다른인자를 받아서 적절한 인스턴스로 변환하는 static 메서드를 저장할 static 변수 선언
  - 새 클래스를 사용하게 원본 클래스의 내용 수정
    - 기존 코드를 사용하는 인터페이스를 놔두되 static필드는 새클래스를 통해 코드를 생성하게 수정
  - 컴파일, 테스트
  - 원본 클래스 코드를 사용하는 원본 클래스 안의 각 메서드마다, 그에 대응하는 새 클래스를 사용하는 새 메서드를 작성하자.
  - 원본 클래스 호출부분을 한 번에 하나씩 새 인터페이스 호츨로 수정하자
  - 원본 클래스 호출 부분을 한번에 하나씩 새 인터페이스 호출로 수정
  - 컴파일, 테스
  - 기존 코드 사용 인터페이스 삭제, static 변수 선언 삭제
  - 컴파일, 테스트

### 분류 부호를 하위 클래스로 전환 Replace Type code with subcalss

- 클래스 기능에 영향을 주는 변경불가 분류 부호가 있을 땐 분류 부호를 하위클래스로 만들자.
  - 적용 불가
    - 분류 부호의 값이 객체 생성 후 변할때
    - 다른 이유로 분류 부호를 이미 하위클래스로 만들었을때
    - 분류 부호를 상태/전략 패턴으로 전환을 실시할때

* 방법
  - 분류 부호를 자체 캡슐화
    - 분류 부호가 생성자 메서드로 전달될 땐 생성자 메서드를 팩토리 메서드로 전환
  - 각 분류 부호 값마다 그에 해당하는 하위클래스 작성, 값을 반환하는 분류 부호 읽기 메서드 재정의
    - 반환 값은 return 문으로 하드코딩 된다, case를 수정할때까진 임시방편으로 취한다.
  - 각 분류 부호 값을 하위 클래스로 만들때마다 컴파일, 테스트
  - 상위클래스의 분류 부호 필드를 삭제. 분류 부호 읽기, 쓰기 메서드를 abstract 타입으로 선언
  - 컴파일, 테스트

### 분류 부호를 상태 / 전략패턴으로 전환 Replace Type code with state/strategy
  - 분류 부호가 클래스의 기능에 영향을 주지만 하위클래스로 전환할 수 없을땐 그 분류부호를 상태 객체로 생성

  * 방법
    - 분류 부호를 자체 캡슐화
    - 분류 부호의 목적을 나타내는 이름으로 새 클래스 작성(상태 객체)
    - 그 상태 객체에 각 분류 부호에 해당하는 하위클래스 추가
    - 상태 객체안에 분류 코드를 반환하는 abstract 메소드 호출을 작성, 올바른 분류 부호를 반환하는 객체 하위클래스 각각에 대한 재정의 메서드 호출
    - 컴파일
    - 원본 클래스 안에서 새 상태객체 나타내는 필드 선언
    - 원본 클래스에 있는 분류 부호 판단 코드를 상태 객체에 위임하게 수정
    - 원본 클래스의 분류부호 쓰기 메서드를 적절한 상태객체 하위클래스의 인스턴스를 할당하게 수정
    - 컴파일, 테스트

### 하위클래스를 필드로 전환 Replace Subclass with Field
- 여러 하위 클래스가 상수 데이터를 반환하는 메서드만 다를땐 각 하위클래스의 메서드를 상위클래스 필드로 전환하고 하위클래스는 전부 삭제하자.


