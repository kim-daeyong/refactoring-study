# Code Smells, 코드에서 나는 악취

## 3.1 Mysterious Name, 기이한 이름

- 코드는 단순 명료하게.
- 이름만 보고도 무슨 일을 하고 어떻게 사용해야 하는지 알 수 있도록 한다.

## 3.2 Duplicated Code, 중복 코드

- 한 클래스의 두 메서드가 똑같은 표현식을 사용한다면 **함수 추출** 을 사용한다.
- 두 메서드가 완전히 동일하지 않다면 **문장 슬라이드** 를 사용해 비슷한 부분을 추출한다.
- 만약 두 메서드의 전체적인 흐름은 비슷하지만 세부 내용이
  다르다면 **[Form Template Method](https://www.refactoring.com/catalog/formTemplateMethod.html)** 를 사용한다.
- 같은 부모로부터 파생된 같은 레벨의 sub class 에서 중복 코드가 발생한다면 **메서드 올리기**를 사용하고 공통으로 사용하는 필드를 추출한다.
- 만약 중복되는 코드가 생성자에 있는 경우 상위 클래스에 중복되는 부분을 올린다.

- 만약 중복되는 코드들이 서로 다른 두 클래스에 있고 서로 계층을 이루지 않고 있다면 상위클래스를 추출하여 중복 코드를 추출한다.
- 하지만 상위클래스를 구현하기 어렵거나 불가능하다면 한 클래스에서 클래스를 추출한 뒤 다른 클래스에서 추출한 클래스를 사용하도록 한다.
- 만약 거대한 조건문에서 조건만 다르고 같은 행동을 하는 코드들이 있다면 **Consolidate Conditional Expression**를 사용해 이들을 추출하고 메소드를 추출한 뒤 알기 쉬운 이름을 정해
  사용한다.

- 만약 조건문에서 계속 반복되는 코드가 있다면 이를 조건문 바깥으로 뺀다.

## 3.3 Long Function, 긴 함수

- 긴 함수는 이해하기 어렵다.
- 주석을 달아야 할 코드는 함수로 만들고 이름에 코드의 의도가 담기도록 적극적으로 함수를 쪼개야 한다.
- 너무 많은 수의 매개변수와 임시 변수는 함추 추출을 어렵게 만든다.
    - 임시 변수를 질의 함수로 변경

- 매개변수를 담는 객체를 생성하여 객체 통째로 넘기기

- 만약 위 방법들이 별로 효과적이지 못했다면 **함수를 명령으로 바꾸기**를 고려하자

- 조건이나 반복문 역시 추출 대상의 실마리를 제공한다.
- 조건문 분해하기

- 함수 추출하기


- 같은 조건을 기준으로 나뉘는 switch가 여러개라면 **조건문을 다형성으로 바꾸기** 를 적용한다.
- 추출한 반복문 코드에 적합한 이름이 떠오르지 않는다면 성격이 다른 두 가지 작업이 섞여있기 때문일 수 있다. 이럴 떄는 과감하게 **반복문 쪼개기**를 적용한다.

## 3.4 Long Parameter List ,긴 매개변수 목록

- 종종 다른 매개변수에서 값을 얻어올 수 있는 매개변수가 있는데 이런 매개변수는 **매개변수를 질의 함수로 바꾸기**를 사용하여 제거할 수 있다.

- 사용중인 데이터 구조에서 값을들 뽑아 각각을 별개의 매개변수로 전달하는 코드는 **객체 통째로 넘기기** 를 사용한다.

- 항상 함께 전달되는 매개변수들은 **매개변수 객체 만들기**를 사용해 하나로 묶는다.
- 함수의 동작 방식을 정하는 플래그 역할의 매새변수는 **플래그 인수 제거하기**로 없애준다.


- 여러 함수가 특정 매개변수들의 값을 공통으로 사용할 때는 **여러 함수를 클래스로 묶기**를 이용하여 공통 값들을 클래스의 필드로 정의한다.

## 3.5 Global data, 전역 데이터

- 어디서든 변경이 가능하고 누가 변경했는지 추적이 힘들다.

## 3.6 Mutablt data, 가변 데이터

- **변수 캡슐화하기**를 적용, 정해놓은 함수를 거쳐야만 값을 수정하도록 변경
- 하나의 변수에 다른 용도에 따른 값을들 저장해야 한다면 **변수 쪼개기**를 사용하여 용도별로 변수를 구분
- 갱신 로직은 다른 코드와 떨어뜨리는 것이 좋다. **문장 슬라이드 하기** 와 **함수 추출하기**를 이용해 무엇인가를 갱신하는 코드로부터 부작용이 없는 코드를 분리한다.
- API를 만들때에는 **질의 함수와 변경 함수 분리하기** 를 사용해 불필요한 변경이 일어나지 않도록 한다.
- **setter 제거하기**를 통해 변수의 유효범위를 줄이는 데 도움이 된다.
- 값을 다른 곳에서 설정할 수 있는 가변 데이터들은 **파생 변수를 질의 함수로 바꾸기**를 사용해야한다.
    - 가변 데이터를 들고 있는 변수들은 해당 변수를 업데이트 하는 함수로 바꿀 수 있다

    - 구조체처럼 내부 필드에 데이터를 담고 있는 변수라면, 일반적으로 **참조를 값으로 바꾸기**를 적용하여 내부 필드를 직접 수정하지 말고 구조체를 통째로 교체한다.

## 3.7 Divergent Change, 뒤엉킨 변경

- 보통 Single Responsibility Principle(단일 책임 원칙)을 지키지 않아 발생한다.
- 순차적으로 진행되는 게 자연스러운 맥락이라면, 다음 맥락에 필요한 데이터를 특정한 데이터 구조에 담아 전달하게 하는 식으로 단계를 분리한다. **단계 쪼개기**
- 전체 처리 과정에서 각기 다른 맥락의 함수를 호출하는 빈도가 높다면, 각 맥락에 해당하는 적당한 모듈들을 만들어서 관련 함수들을 모은다. **함수 옮기기**
- 여러 맥락의 일에 관련하는 함수는 우선 **함수 추출하기**를 먼저 수행한다.
- 모듈이 클래스하면 **클래스 추출하기**를 사용한다.
- 만약 다른 클래스들이 같은 행동을 한다면 상속을 사용하는것도 좋다.

## 3.8 Shotgun Surgery, 산탄총 수술

- 산탄총 수술은 뒤엉킨 변경과 비슷하면서도 완전 다르다.
- 코드를 변경할 때마다 자잘하게 수정해야 하는 클래스가 많을 때 발생한다.
- 변경한 부분이 코드 전반에 퍼져 있다면 찾기도, 수정하기도 어려워진다
- 함께 변경되는 대상들을 **함수 옮기기* 와 **필드 옮기기**로 한 모듈에 묶어두면 좋다.
- 비슷한 데이터를 다루는 함수가 많다면 **여러 함수를 클래스로 묶기**를 사용한다.
- 데이터 구조를 변환하거나 보강하는 함수들에는 **여러 함수를 변환 함수로 묶기**를 적용한다.
- 이렇게 묶은 함수들의 출력 결과를 묶어서 다음 단계의 로직으로 전달할 수 있다면 **단계 쪼개기**를 적용한다.
- 어설프게 분리 된 로직을 **함수 인라인하기** 혹은 **클래스 인라인하기**같은 인라인 리팩터링을 적용하는것도 좋다.

## 3.9 Feature Envy, 기능 편애

- 자기가 속한 모듈의 함수나 데이터보다 다른 모듈의 함수나 데이터와 상호작용이 더 많을 때 발생한다.
- **함수 옮기기**를 사용해 해당 데이터 근처로 옮겨준다.
- 때로는 함수의 일부에서만 기능을 편애할 수 있다. 이런 경우에는 **함수 추출하기**를 사용하여 해당 함수를 독립 함수로 빼내고 **함수 옮기기**로 해당 모듈로 보내준다
- 하지만 어디로 옮길지가 불분명한 경우 가장 많은 데이터를 포함한 모듈로 옮기면 편하다.
- 혹은 **함수 추출하기**로 함수를 여러 조각으로 나눈 후 각각을 적합한 모듈로 옮기면 더 쉽게 해결 가능하다.
- 전략 패턴, 방문자 패턴, 그리고 자기위임은 기능 편애 리팩터링을 거스르는 패턴이다.
- 이들은 모두 뒤엉킨 변경을 해결하기 위한 패턴들로 데이터와 이 데이터를 다루는 동작은 함께 변경해야 할 때가 많지만 예외가 있다.
    - 이런 경우 같은 데이터를 다루는 코드를 위의 전략패턴등을 사용해 한 곳에서 변경할 수 있도록 옮긴다.

## 3.10 Data Clumps, 데이터 뭉치

- 간혹 데이터 항목(필드)들이 여러 곳에서 항상 함께 뭉쳐 다니는 현상을 말한다. 클래스 두어 개의 필드에서 ,혹은 여러 메서드의 시그니처에서 함께 발견되기도 한다.
- 이런 데이터 뭉치들은 보금자리를 따로 마련해야한다.
- 우선 필드 형태의 데이터 뭉치를 찾아 **클래스 추출하기**로 하나의 객체로 묶는다.
- 매서드 시그니처에 있는 데이터 뭉치들은 먼저 **매개변수 객체 만들기**나 **객체 통째로 넘기기**를 적용해 매개변수의 수를 줄인다.
- 데이터 뭉치를 판별하는 방법은 값을 하나 삭제했을 때 나머지 데이터만으로는 의미가 없어진다면 객체로 만들어야 하는 데이터 뭉치다.
- 기능 편애를 해결하면서 새로운 클래스가 생성 되었다면 해당 클래스로 옮기면 좋을 동작은 없는지 살펴본다.

## 3.11 Primitive Obsession, 기본형 집착

- 자신의 상황에 맞는 기초 타입을 직접 정의하지 않고 단순히 기본형만 쓸 때 나타난다.

- **기본형 객체로 만들기**
- 기본형으로 표현된 코드가 조건부 동작을 제어하는 타입 코드로 쓰였다면 **타입 코드를 서브클래스로 바꾸기**와**조건부 로직을 다형성으로 바꾸기**를 차례로 적용한다.

- 자주 함께 몰려다니는 기본형 그룹도 **클래스 추출하기**와 **매개변수 객체 만들기**를 사용해준다.

## 3.12 Repeated Switches, 반복되는 switch문

- 중복되는 switch문이 문제되는 이유는 조건절을 추가할 때마다 다른 switch문도 모두 찾아서 수정해야 하기 때문
- **조건부 로직을 다형성으로 바꾸기**를 사용해서 수정한다.

## 3.13 Loops, 반복문

- 일급 함수를 지원하는 언어가 많아진 지금은 **반복문을 파이프라인으로 바꾸기**를 통해 제거한다.

## 3.14 Lazy Element, 성의 없는 요소
- 원래는 풍성했던 클래스가 리팩터링을 거치며 역할이 줄어들었을 수 있다.
- 이런 클래스들은 **함수 인라인하기**, **클래스 인라인하기**로 처리하고 상속을 사용했다면 **계층 합치기**를 사용한다.

## 3.15 Speculative Generality, 추측성 일반화
- 나중에 필요할지도 모른다는 추축으로 당장 필요없는 모든 종류의 후킹포인트와 특이 케이스 로직을 작성해둔 코드에서 발생한다.
- 하는 일이 거의 없는 추상 클래스는 **계층 합치기**로 제거한다.
- 쓸데없이 위임하는 코드는 **함수 인라인하기**나 **클래스 인라인하기**로 삭제한다.
- 본문에서 사용하지 않는 매개변수는 **함수 선언 바꾸기**로 없앤다. 나중에 필요할 거라는 생각에 추가하고 한 번도 사용하지 않은 매개변수도 이 기법으로 없앤다.
- 테스트 코드 말고는 사용하는 곳이 없는 함수나 클래스에서 흔히 발견된다. 이런 경우 테스트 코드를 삭제하고 **죽은 코드 제거하기**를 사용한다.

## 3.16 Temporary Field, 임시 필드
- 특정 상황에서만 값이 설정되는 필드를 가진 클래스가 있다. 
- 이런 필드들은 **클래스 추출하기**를 사용하여 있어야 할 곳으로 옮긴다. 그런 다음 **함수 옮기기**로 임시 필드들과 관련된 코드를 모조리 새 클래스에 몰아넣는다.
- 또한 임시 필드들이 유효한지 확인한 후 동작하는 조건부 로직이 있을 수 있는데 **특이 케이스 추가하기**로 필드들이 유효하지 않을 때는 위한 대안 클래스를 만들어서 제거한다.

## 3.17 Message Chains 메시지 체인
- 클라이언트가 한 객체를 통해 다른 객체를 얻은 뒤 방금 얻은 객체에 또 다른 객체를 요청하는 식으로 다른 객체를 요청하는 작업이 연쇄적으로 이어지는 코드를 말한다.
- 이는 클라이언트가 객체 내비게이션 구조에 종속되었음을 의미한다.
- **위임 숨기기**를 사용해 해결한다.
- 다만 너무 과하게 사용하면 중간 객체들이 **중개자**가 되버릴 수 있다.
- **함수 추출하기**로 결과 객체를 사용하는 코드 일부를 따로 빼낸 다음 **함수 옮기기**로 체인을 숨길 수 있는지 살펴본다.

## 3.18 Middle Man, 중개자
- 클래스가 제공하는 메서드 중 절반이 다른 클래스에 구현을 위임한다면 **중개가 제거하기**를 활용해 실제로 일을 하는 객체와 직접 소통하게 한다.
- 위임 메서드를 제거한 수 남는 일이 거의 없다면 호출하는 쪽으로 인라인하자(**함수 인라인하기**)

## 3.19 Insider Trading, 내부자 거래

## 3.20 Large Class, 거대한 클래스
- 한 클래스가 너무 많은 일을 하면 필드가 늘어나며 이는 곧 클래스에 중복되는 코드가 생길 가능성이 높다.
- **클래스 추출하기**로 필드를 일부 묶는다.
- 만약 이렇게 추출한 컴포넌트를 원래 클래스와 상속 관계로 만드는게 좋다면 **슈퍼클래스 추출하기**나 **타입코드를 서브클래스로 바꾸기**를 사용한다.
- 클래스가 모든 필드를 사용하지 않을수 있는데 이럴 때는 위의 추출 기법들을 여러번 적용해야 할 수도 있다.
- 중복 코드들의 공통 부분을 작은 메서드들로 뽑아내는 것도 좋은 방법이다.
- 클라이언트들이 거대 클래스의 특정 기능 그룹만 주로 사용하는지 살피고 각각의 기능 그룹이 개별 클래스로 추출될 후보이다.
- **클래스 추출하기**, **슈퍼클래스 추출하기**, **타입 코드를 서브클래스로 바꾸기** 등을 활용해 여러 클래스로 분리한다.

## 3.21 Alternative Classes with Different Interfaces, 서로 다른 인터페이스의 대안 클래스들
- 클래스 사용의 가장 큰 장점은 필요에 따라 언제든 다른 클래스로 교체할 수 있다는 것이지만 교체하기 위해서는 인터페이스가 같아야 한다.
- 이때는 **함수 선언 바꾸기**로 메서드 시그니처를 일치시킨다.
- 위의 작업으로도 부족하다면 **함수 옮기기**를 이용해 인터페이스가 같아질 때까지 필요한 동작들을 클래스 안으로 밀어 넣는다.
- 그러다 대안 클래스들 사이에 중복 코드가 생기면 **슈퍼클래스 추출하기** 적용을 고려한다.

## 3.22 Data Class, 데이터 클래스

## 3.23 Refudes Bequest, 상속 포기

## 3.24 Comments, 주석
- 주석을 장황하게 써야 하는 경우는 대부분 코드를 잘못 작성했기 때문이다.
- **함수 추출하기**를 적용해 특정 코드 블록이 하는 일에 주석을 남기고 이후에도 여전히 섬령이 필요하다면 **함수 선언 바꾸기**로 함수 이름을 바꾼다.
- 시스템이 동작하기 위한 선행조건을 명시하고 싶다면 **어서션 추가하기**를 사용한다.

[참조](https://raw.githubusercontent.com/irerin07/refactoring/master/readme/3.md)